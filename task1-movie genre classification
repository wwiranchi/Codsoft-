#include <stdio.h>
#include <stdlib.h>
#include "svm.h"

int main() {
    // Load the training data
    struct svm_problem prob;
    struct svm_node *x_space;
    int max_line_len = 1024;
    char *line = (char *)malloc(max_line_len*sizeof(char));

    prob.l = 0;
    prob.y = NULL;
    prob.x = NULL;

    FILE *fp = fopen("training_data.txt", "r");
    while (fgets(line, max_line_len, fp) != NULL) {
        int i = 0;
        char *pch = strtok(line, " ");
        while (pch != NULL) {
            if (i == 0) {
                // Parse label
                prob.y = (double *)realloc(prob.y, sizeof(double)*(prob.l+1));
                prob.y[prob.l] = atof(pch);
            } else {
                // Parse features
                prob.x = (struct svm_node **)realloc(prob.x, sizeof(struct svm_node *)*(prob.l+1));
                int feature_index, value;
                sscanf(pch, "%d:%d", &feature_index, &value);

                prob.x[prob.l] = (struct svm_node *)malloc(2*sizeof(struct svm_node));
                prob.x[prob.l][0].index = feature_index;
                prob.x[prob.l][0].value = value;
                prob.x[prob.l][1].index = -1; // Indicates end of features
            }
            pch = strtok(NULL, " ");
            i++;
        }
        prob.l++;
    }
    fclose(fp);
    free(line);

    // Train the model
    struct svm_parameter param;
    param.svm_type = C_SVC;
    param.kernel_type = LINEAR;
    param.C = 1;
    param.eps = 1e-3;
    param.probability = 1;

    struct svm_model *model = svm_train(&prob, &param);

    // Make predictions
    struct svm_node *x = (struct svm_node *)malloc(2*sizeof(struct svm_node));
    x[0].index = 1;  // Assuming first feature index is 1
    x[0].value = 1;  // Assuming first feature value is 1
    x[1].index = -1; // Indicates end of features

    double prediction = svm_predict(model, x);
    printf("Predicted label: %f\n", prediction);

    // Free memory
    svm_free_and_destroy_model(&model);
    free(x);
    for (int i = 0; i < prob.l; i++) {
        free(prob.x[i]);
    }
    free(prob.x);
    free(prob.y);

    return 0;
}

